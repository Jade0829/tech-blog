---
layout:     post
title:      "Lustre Changelog DR"
date:       2025-11-28
author:     김 재환 (jhkim@gluesys.com)
categories: blog
tags:       [Lustre, Changelog, DR, rsync, sync ]
cover:      ""
main:       ""
---

## 인사말

이전 블로그 Lustre_FID_1[^1]과 Lustre_FID_2[^2]를 통해 러스터 파일시스템에서 파일 생성 시 내부 동작 방식을 확인했습니다. 특히 Lustre가 파일을 고유한 FID(File Identifier)로 관리하는 방식을 살펴보면서, 러스터 파일시스템의 내부 동작 원리를 이해하셨을 것입니다.

이번 블로그에서는 러스터 파일시스템에서 파일 생성, 수정, 삭제와 같은 모든 이벤트를 기록하는 changelog[^3]와 이를 활용한 글루시스의 DR(Disaster Recovery) 솔루션을 소개하려고 합니다.

올해 국가정보자원관리원에서 발생한 데이터 센터 화재와 같은 재난 상황에서도 시스템이 정상적으로 동작하려면 데이터 손실 없이 효과적인 백업 및 복구 전략이 필수적입니다. 특히 Lustre와 같은 분산 파일시스템에서는 전체 데이터를 주기적으로 동기화하는 전통적인 방식보다, 변경된 부분만 효율적으로 추적하고 복제할 수 있는 방법이 중요합니다.
&nbsp;

## Lustre Changelog

Lustre Changelog는 러스터 파일시스템에서 발생하는 모든 메타데이터 변경 사항을 기록하는 기능입니다. 파일 생성, 수정, 삭제, 권한 변경, 디렉토리 구조 변경 등과 같은 이벤트들이 시간 순서대로 기록되며, 이를 통해 파일시스템의 변경 이력을 추적할 수 있습니다.

### Changelog의 동작 원리

Changelog는 MDS(Metadata Server)에서 관리되며, 각 MDT(Metadata Target)별로 독립적으로 기록됩니다. 클라이언트에서 메타데이터 변경 작업이 발생하면, MDS는 해당 작업을 처리한 후 Changelog에 이벤트를 기록합니다. 

Changelog는 내부적으로 순차적인 로그 파일 형태로 저장되며, 각 로그 엔트리는 다음과 같은 정보를 포함합니다:

- **타임스탬프**: 이벤트 발생 시간
- **FID**: 변경된 파일 또는 디렉토리의 FID(File Identifier)
- **이벤트 타입**: CREATE, UNLINK, RENAME, SETATTR 등의 작업 유형
- **부가 정보**: 작업과 관련된 추가 메타데이터

Changelog는 비동기적으로 기록되기 때문에 일반적인 파일시스템 작업 성능에는 거의 영향을 주지 않습니다. 다만, 활성화된 이벤트 타입이 많을수록 디스크 사용량이 증가할 수 있으므로, 실제로 필요한 이벤트만 선택적으로 활성화하는 것이 좋습니다.


### Changelog 활성화 및 확인

Changelog 기능을 사용하려면 먼저 MDS에서 Changelog를 활성화해야 합니다. Changelog는 기본적으로 비활성화되어 있으며, 다음과 같이 활성화할 수 있습니다:

```shell
# Changelog 활성화
lctl set_param mdd.*.changelog_mask="CREAT UNLINK RENAME SETATTR"

# Changelog 상태 확인
lctl get_param mdd.*.changelog_mask
```

`changelog_mask` 파라미터를 통해 기록할 이벤트 타입을 선택적으로 지정할 수 있습니다. 필요한 이벤트만 기록하도록 설정하면 디스크 사용량을 절약할 수 있습니다.

#### changelog_mask 이벤트 타입

`changelog_mask`에서 사용할 수 있는 주요 이벤트 타입은 다음과 같습니다:

**파일 및 디렉토리 작업:**
- **CREAT**: 파일 또는 디렉토리 생성
- **UNLINK**: 파일 또는 디렉토리 삭제
- **MKDIR**: 디렉토리 생성
- **RMDIR**: 디렉토리 삭제
- **RENAME**: 파일 또는 디렉토리 이름 변경

**파일 속성 및 메타데이터:**
- **SETATTR**: 파일 속성 변경 (권한, 소유자, 그룹 등)
- **SATTR**: 파일 속성 설정 (SETATTR과 유사하지만 세부 동작이 다름)
- **XATTR**: 확장 속성(Extended Attribute) 설정 또는 변경
- **TRUNCATE**: 파일 크기 변경

**파일 접근:**
- **OPEN**: 파일 열기
- **CLOSE**: 파일 닫기

**HSM 관련:**
- **HSM**: HSM(Hierarchical Storage Management) 관련 작업 (파일 아카이빙, 복원 등)

**기타:**
- **MARK**: 마커 이벤트 (특정 시점을 표시하기 위한 이벤트)
- **ATIME**: 접근 시간 변경 (기본적으로 비활성화)
- **GXATR**: 확장 속성 접근 (기본적으로 비활성화)
- **NOPEN**: 파일 열기 거부 (기본적으로 비활성화)

일부 이벤트 타입(ATIME, GXATR, NOPEN 등)은 기본적으로 비활성화되어 있으며, 이러한 이벤트를 기록하려면 명시적으로 mask에 포함시켜야 합니다. 다만, 이러한 이벤트는 빈번하게 발생할 수 있어 디스크 사용량이 크게 증가할 수 있으므로 신중하게 선택해야 합니다.

### Changelog 읽기

Changelog를 읽기 위해서는 `lfs changelog` 명령어를 사용합니다:

```shell
# 특정 MDT의 Changelog 읽기
lfs changelog <MDT_device>

# 특정 시점 이후의 Changelog 읽기
lfs changelog <MDT_device> <start_record>

# 실시간으로 Changelog 모니터링
lfs changelog <MDT_device> --follow
```

Changelog는 순차적인 레코드 번호를 가지며, 특정 레코드 번호부터 읽어올 수 있습니다. 각 레코드는 다음과 같은 형식으로 출력됩니다:

```
12345 08/01/2025 14:30:25 CREAT [0x200000007:0x1:0x0] /lustre/test/file.txt
12346 08/01/2025 14:30:26 MODIFY [0x200000007:0x1:0x1] /lustre/test/file.txt
12347 08/01/2025 14:30:27 UNLINK [0x200000007:0x1:0x1] /lustre/test/file.txt
```

각 레코드는 레코드 번호, 타임스탬프, 이벤트 타입, FID, 그리고 파일 경로(가능한 경우)를 포함합니다. 이 정보를 활용하여 특정 시점 이후의 변경 사항만 추출하거나, 특정 파일의 변경 이력을 추적할 수 있습니다.

### Changelog의 활용

Changelog의 가장 큰 장점은 파일시스템의 전체 스캔 없이 변경된 파일만 식별할 수 있다는 점입니다. 전통적인 `rsync`와 같은 도구는 전체 파일시스템을 스캔하여 변경 사항을 찾아야 하지만, Changelog를 활용하면 최근 변경된 파일만 효율적으로 처리할 수 있습니다.

이러한 특성으로 인해 Changelog는 다음과 같은 용도로 활용됩니다:

- **증분 백업**: 변경된 파일만 선택적으로 백업
- **DR(Disaster Recovery)**: 원격 사이트로 변경 사항만 동기화
- **감사(Audit)**: 파일시스템 변경 이력 추적
- **HSM**: 자주 사용되지 않는 파일을 계층적 스토리지로 마이그레이션

&nbsp;


## Gluesys DR

글루시스의 Lustre DR 솔루션은 Lustre Changelog를 활용하여 실시간으로 파일시스템 변경 사항을 원격 사이트에 동기화하는 시스템입니다. 전통적인 전체 스캔 기반 동기화 방식과 달리, 변경된 파일만 효율적으로 추적하고 복제하여 네트워크 대역폭과 처리 시간을 크게 절감할 수 있습니다.

### 시스템 아키텍처

글루시스 DR 솔루션은 세 가지 주요 컴포넌트로 구성됩니다:

1. **모니터링 컴포넌트**: Lustre Changelog를 실시간으로 모니터링하고 이벤트를 수집하는 모니터링 데몬
2. **소스 서버 컴포넌트**: 소스 서버에서 실행되며, 수집된 이벤트를 처리하고 동기화 작업을 수행하는 서버
3. **타겟 서버 컴포넌트**: 타겟 서버에서 실행되며, 원격에서 전송된 파일 작업 요청을 처리하는 서버

이 세 컴포넌트는 Redis Stream을 통해 이벤트를 전달하고, gRPC를 통해 원격 파일 작업을 수행합니다.

#### 컴포넌트별 상세 기능

**모니터링 컴포넌트**
- MDT가 여러 개인 경우 각 MDT별로 독립적인 프로세스로 동작
- 메인 쓰레드와 두 개의 서브 쓰레드로 구성된 멀티 쓰레드 구조
  - 메인 쓰레드: MDT 모니터링 및 리소스 관리
  - 모니터링 쓰레드: Lustre changelog 이벤트 수집
  - 필터 쓰레드: 이벤트 필터링 및 Redis 저장
- 하이브리드 Redis Stream 저장 (MDT별 스트림 + 통합 스트림)
- 이벤트 타입별 분류 (create_modify, rename_delete)

**소스 서버 컴포넌트**
- Redis Stream에서 이벤트를 읽어 처리
- MDT별 Changelog Index 관리 및 추적


**타겟 서버 컴포넌트**
- gRPC 서버로 원격 파일 작업 처리
- 소스 서버와 타겟 서버 간 경로 자동 변환
- 실패 이벤트 상세 분석 및 재시도 가능 여부 판단

### 동작 원리

#### 1. 이벤트 수집 단계

모니터링 컴포넌트는 Lustre의 `llapi_changelog_recv()` API를 사용하여 파일시스템 변경 이벤트를 실시간으로 수집합니다. 각 MDT(Metadata Target)별로 독립적인 프로세스로 동작하며, 수집된 이벤트는 Redis Stream에 저장됩니다.

이 과정에서 불필요한 파일(예: Vim 임시 파일, 백업 파일 등)은 설정 파일의 `excludePatterns`를 통해 필터링되어 동기화 대상에서 제외됩니다. 또한 시스템 재시작 시 중복 처리를 방지하기 위해 Redis에서 마지막 처리된 Changelog Index를 로드하여 해당 지점부터 이벤트를 읽기 시작합니다.

**Redis Stream 구조**

수집된 이벤트는 Redis Stream에 다음과 같은 구조로 저장됩니다:

- **MDT별 스트림**: `changelog:{mdt_name}:{source_name}` 형식으로 각 MDT의 이벤트를 독립적으로 저장
- **통합 스트림**: 
  - `changelog:{source_name}:create_modify` - 파일 생성/수정 이벤트
  - `changelog:{source_name}:rename_delete` - 파일명 변경/삭제 이벤트

각 스트림 엔트리는 다음과 같은 정보를 포함합니다:
- **이벤트 타입**: CREATE, MODIFY, RENAME, DELETE 등
- **파일 경로**: 변경된 파일의 전체 경로
- **MDT 정보**: 이벤트가 발생한 MDT 이름
- **Index**: Changelog Index 번호
- **타임스탬프**: 이벤트 발생 시간

이러한 구조를 통해 이벤트 타입별로 효율적으로 처리할 수 있으며, MDT별 병렬 처리도 가능합니다.

#### 2. 동기화 처리 단계

소스 서버 컴포넌트는 Redis Stream에서 이벤트를 읽어 이벤트 타입에 따라 적절한 동기화 방법을 선택하여 처리합니다. 동기화는 이벤트 타입에 따라 두 가지 방식으로 나뉩니다:

**2.1 rsync를 통한 동기화 (CREATE/MODIFY 이벤트)**

파일 생성이나 수정 이벤트의 경우, 대용량 데이터 전송에 최적화된 `rsync`를 사용합니다. 소스 서버 컴포넌트는 변경된 파일 목록을 수집하고, SSH를 통해 타겟 서버로 파일을 복사합니다. 이 방식은 파일의 실제 데이터를 효율적으로 전송하는 데 적합합니다.

동기화 과정은 다음과 같이 진행됩니다:

1. **이벤트 수집**: Redis Stream에서 CREATE/MODIFY 이벤트를 읽어 파일 목록 생성
2. **파일 존재 확인**: 각 파일의 존재 여부를 사전 확인하여 존재하지 않는 파일은 제외
3. **임시 파일 생성**: 존재하는 파일들의 상대 경로를 임시 파일에 기록
4. **rsync 실행**: `--ignore-missing-args` 옵션을 사용하여 안전하게 파일 전송
5. **결과 확인**: rsync 실행 후 파일 존재 여부를 재확인하여 삭제된 파일은 크기 비교에서 제외
6. **Index 업데이트**: 동기화 완료 후 Changelog Index 업데이트



**2.2 gRPC를 통한 동기화 (RENAME/DELETE 이벤트)**

파일명 변경이나 삭제 이벤트의 경우, 메타데이터만 처리하면 되므로 gRPC를 통해 타겟 서버 컴포넌트에 직접 요청합니다. 타겟 서버 컴포넌트는 gRPC 요청을 받아 파일 이동, 삭제 등의 작업을 수행하며, 소스 서버와 타겟 서버 간의 경로 차이를 자동으로 변환하여 올바른 위치에 동기화합니다.

gRPC를 통한 동기화 과정은 다음과 같습니다:

1. **이벤트 수집**: Redis Stream에서 RENAME/DELETE 이벤트를 읽어 요청 목록 생성
2. **gRPC 요청 전송**: 타겟 서버의 `RmvSync` API를 호출하여 파일 작업 요청
3. **경로 변환**: 소스 서버 경로를 타겟 서버 경로로 자동 변환
4. **파일 작업 실행**: 타겟 서버에서 파일 이동 또는 삭제 수행
5. **결과 반환**: 성공/실패 여부와 상세 오류 정보를 소스 서버에 반환
6. **Index 업데이트**: 성공한 작업에 대해서만 Changelog Index 업데이트


#### 3. Changelog Index 관리

시스템 재시작 시 중복 처리나 누락을 방지하기 위해 Changelog Index를 추적하고 관리합니다. 모니터링 컴포넌트는 시작 시 Redis에서 마지막 동기화 완료된 Index를 로드하여 해당 지점부터 changelog를 읽기 시작하고, 소스 서버 컴포넌트는 동기화 완료 후 해당 Index를 업데이트합니다. 이를 통해 시스템이 중단되어도 정확한 지점부터 동기화를 재개할 수 있습니다.

Redis에는 각 MDT별로 `changelog:MDT0000`, `changelog:MDT0001` 형식의 키로 마지막 처리된 Index가 저장되며, 동기화가 완료될 때마다 이 값이 업데이트됩니다.

#### 4. 오류 처리 및 재시도 메커니즘

동기화 과정에서 발생하는 오류를 효율적으로 처리하기 위해 재시도 메커니즘을 구현했습니다. rsync 실행 시 실패한 파일 목록을 분석하여, 재시도 가능한 오류와 재시도 불가능한 오류를 구분합니다.

재시도 가능한 오류(예: 일시적인 네트워크 오류, 파일 잠금 등)는 Redis Stream의 재시도 전용 큐에 저장됩니다. 다음 동기화 작업 시 이 재시도 큐의 파일들도 함께 처리되어, 일시적인 문제로 실패한 파일들이 자동으로 복구됩니다.

재시도 불가능한 오류(예: 파일이 존재하지 않음, 권한 오류 등)는 상세한 오류 정보와 함께 로그에 기록되어 관리자가 수동으로 처리할 수 있도록 합니다. 각 실패 이벤트에는 에러 메시지, 에러 코드, 재시도 가능 여부 등의 정보가 포함되어 있어 문제 진단이 용이합니다.

### 기존 rsync 전체 스캔 방식과의 비교

전통적인 rsync 기반 동기화 방식은 전체 파일시스템을 주기적으로 스캔하여 변경된 파일을 찾아 동기화합니다. 이 방식은 구현이 간단하지만 대규모 파일시스템에서는 여러 한계점이 있습니다.

#### SSH를 통한 rsync 방식

SSH를 직접 사용하는 방식은 다음과 같은 특징을 가집니다:

**장점:**
- 구현이 간단하고 널리 사용되는 방식
- SSH의 암호화 기능을 활용한 안전한 전송
- 별도의 서버 프로세스 불필요

**단점:**
- 전체 파일시스템 스캔으로 인한 긴 처리 시간
- 대규모 파일시스템에서 스캔 시간이 수 시간에서 수십 시간 소요
- 네트워크 대역폭을 비효율적으로 사용 (변경되지 않은 파일도 확인)
- 스캔 중 발생한 변경 사항은 다음 스캔까지 반영되지 않음

#### sshd 데몬을 통한 rsync 방식

sshd 데몬을 통해 rsync를 실행하는 방식은 SSH 연결을 재사용하거나 최적화할 수 있지만, 근본적인 문제는 동일합니다:

**장점:**
- SSH 연결 재사용으로 오버헤드 감소 가능
- 중앙 집중식 관리 가능

**단점:**
- 여전히 전체 파일시스템 스캔 필요
- 스캔 시간이 파일시스템 크기에 비례하여 증가
- 실시간 동기화 불가능
- RPO(Recovery Point Objective)가 스캔 주기에 의존

#### Changelog 기반 DR 솔루션의 장점

글루시스 DR 솔루션은 Changelog를 활용하여 이러한 문제점들을 해결합니다:

**효율성:**
- 네트워크 대역폭 절감: 실제 변경된 데이터만 전송
- 처리 시간 단축 : 전체 스캔 불필요, 변경된 파일만 식별하여 처리

**실시간성:**
- 이벤트 발생 즉시 처리: RPO를 최소화
- 지속적인 모니터링: 스캔 주기에 의존하지 않음

**확장성:**
- 파일시스템 크기에 관계없이 일정한 처리 시간
- MDT별 독립 처리로 병렬 처리 가능

**정확성:**
- Changelog Index 추적으로 중복/누락 방지
- 모든 변경 사항을 순차적으로 처리

### 주요 특징

#### 효율적인 증분 동기화

전체 파일시스템을 스캔하는 대신, Changelog를 통해 변경된 파일만 식별하여 동기화합니다. 이를 통해 대규모 파일시스템에서도 빠른 동기화가 가능하며, 네트워크 대역폭을 효율적으로 활용할 수 있습니다.

#### 실시간 동기화

이벤트 발생 즉시 처리되므로, 재해 발생 시 최신 데이터까지 복구할 수 있습니다. 또한 Changelog Index를 추적하여 시스템 재시작 후에도 중복 처리나 누락 없이 동기화를 계속할 수 있습니다.


#### 안정적인 오류 처리

동기화 실패 시 상세한 오류 정보를 기록하고, 재시도 가능한 작업은 자동으로 재시도 큐에 추가하여 처리합니다. 실패한 파일 목록을 추적하여 관리자가 수동으로 처리할 수 있도록 지원합니다.

#### 파일 필터링 시스템

설정 파일의 `excludePatterns`를 통해 불필요한 파일(임시 파일, 백업 파일 등)을 동기화 대상에서 제외할 수 있습니다. 기본적으로 Vim 임시 파일(.swp, .swo, .swx)과 백업 파일(~)이 제외됩니다.

### 이벤트 타입별 처리 방식

글루시스 DR 솔루션은 이벤트 타입에 따라 최적화된 처리 방식을 사용합니다:

| 이벤트 타입 | 처리 방식 | 사용 도구 | 설명 |
|------------|----------|----------|------|
| CREATE | rsync | rsync | 새로 생성된 파일을 타겟 서버로 복사 (HLINK, SLINK 포함) |
| MODIFY | rsync | rsync | 수정된 파일의 변경 사항을 동기화 (MTIME, TRUNC, SATTR 포함) |
| RENAME | gRPC | moveFile | 파일명 변경을 타겟 서버에서 직접 처리 |
| DELETE | gRPC | deleteFile | 파일 삭제를 타겟 서버에서 직접 처리 |
| RMDIR | gRPC | deleteFile | 디렉토리 삭제를 타겟 서버에서 직접 처리 |

**MODIFY 이벤트 세부 타입:**
- **MTIME**: 파일 수정 시간 변경
- **TRUNC**: 파일 크기 변경 (tfid를 사용하여 전체 경로 조회)
- **SATTR**: 파일 속성 변경 (tfid를 사용하여 전체 경로 조회)

### 시스템 구성

글루시스 DR 솔루션은 다음과 같은 기술 스택으로 구성됩니다:

- **모니터링**: C 언어로 구현된 모니터링 컴포넌트가 Lustre API(`llapi_changelog_recv()`)를 직접 호출하여 이벤트 수집. C 언어를 선택한 이유는 Lustre API와의 직접적인 통합이 필요하고, 실시간 성능이 중요한 모니터링 작업에 적합하기 때문입니다.

- **이벤트 큐**: Redis Stream을 사용하여 이벤트를 비동기적으로 전달. Redis Stream은 순서가 보장되는 로그 구조로, 이벤트의 순차적 처리가 중요한 DR 솔루션에 적합합니다. 또한 Consumer Group 기능을 통해 여러 소비자가 안전하게 이벤트를 읽을 수 있습니다.

- **원격 통신**: gRPC를 사용하여 타겟 서버와 통신. gRPC는 HTTP/2 기반의 고성능 RPC 프레임워크로, 타입 안전성과 효율적인 직렬화를 제공합니다. 파일 메타데이터 작업에 최적화되어 있습니다.

- **파일 동기화**: SSH 기반 rsync를 사용하여 안전하고 효율적인 파일 전송. rsync는 증분 동기화에 최적화된 도구로, 변경된 부분만 전송하여 네트워크 대역폭을 절약합니다. SSH를 통해 암호화된 안전한 전송을 보장합니다.

- **설정 관리**: JSON 형식의 설정 파일. JSON은 가독성이 좋고 다양한 프로그래밍 언어에서 쉽게 파싱할 수 있어 설정 관리에 적합합니다.

### 활용 시나리오

이 솔루션은 다음과 같은 시나리오에서 효과적으로 활용할 수 있습니다:

- **데이터 센터 간 백업**: 주요 데이터 센터의 변경 사항을 백업 데이터 센터에 실시간으로 복제하여 재해 발생 시 빠른 복구 지원
- **재해 복구**: 재난 발생 시 최신 데이터까지 포함하여 빠른 복구 지원
- **지역별 복제**: 지리적으로 분산된 사이트 간 데이터 동기화로 지역별 서비스 제공
- **개발/운영 환경 동기화**: 운영 환경의 변경 사항을 개발 환경에 반영하여 테스트 환경 구축

글루시스의 Lustre DR 솔루션은 이러한 기능들을 통해 대규모 Lustre 파일시스템 환경에서 안정적이고 효율적인 재해 복구를 지원합니다.

&nbsp;

## 마치며

이번 블로그에서는 Lustre 파일시스템의 Changelog 기능과 이를 활용한 글루시스의 DR(Disaster Recovery) 솔루션에 대해 알아보았습니다.

먼저 Lustre Changelog의 동작 원리와 활성화 방법, 그리고 다양한 이벤트 타입에 대해 살펴보았습니다. Changelog는 파일시스템의 전체 스캔 없이 변경된 파일만 효율적으로 추적할 수 있게 해주는 핵심 기능입니다. 비동기적으로 기록되기 때문에 파일시스템 성능에 미치는 영향이 최소화되며, 필요한 이벤트만 선택적으로 활성화하여 디스크 사용량을 관리할 수 있습니다.

이어서 글루시스 DR 솔루션의 아키텍처와 동작 원리를 설명했습니다. 세 가지 주요 컴포넌트(모니터링, 소스 서버, 타겟 서버)가 Redis Stream과 gRPC를 통해 협력하여 실시간으로 파일시스템 변경 사항을 원격 사이트에 동기화하는 방식을 확인했습니다. 

특히 주목할 만한 점은 이벤트 타입에 따라 rsync와 gRPC를 선택적으로 사용하는 이원화된 접근 방식입니다. 파일 생성/수정은 대용량 데이터 전송에 최적화된 rsync를 사용하고, 파일명 변경/삭제는 메타데이터만 처리하는 gRPC를 사용함으로써 네트워크 효율성과 처리 속도를 극대화합니다.

또한 Changelog Index를 추적하여 시스템 재시작 후에도 중복 처리나 누락 없이 동기화를 계속할 수 있으며, 재시도 메커니즘을 통해 일시적인 오류로 실패한 파일들을 자동으로 복구할 수 있습니다. 이러한 기능들을 통해 전통적인 전체 스캔 방식의 한계를 극복하고, 대규모 파일시스템에서도 효율적이고 안정적인 DR을 실현할 수 있습니다.

다음 시간에는 ZFS 파일시스템을 기반으로 한 DR 솔루션에 대해 소개하겠습니다. ZFS의 고유한 기능들(스냅샷, 복제 등)을 활용한 DR 솔루션이 Lustre와 어떤 차이점을 가지는지, 그리고 각각의 장단점은 무엇인지 알아보는 시간을 가져보겠습니다.

&nbsp;


## 각주

[^1]: Lustre_FID_1 : https://tech.gluesys.com/blog/2025/03/13/Lustre_FID_1.html
[^2]: Lustre_FID_2 : https://tech.gluesys.com/blog/2025/09/01/Lustre_FID_2.html
[^3]: changelog : https://doc.lustre.org/lustre_manual.xhtml#lustre_changelogs
